<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
      }
    }
    </script>



<script type="module">

import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

/* Création de la scène et de la camera 
_________________________________________*/

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.Fog( 0xcccccc, 10, 15 );

const camera = new THREE.PerspectiveCamera(
    75, 
    window.innerWidth / window.innerHeight, 
    0.1, 
    1000
);
camera.position.z = 5;

/* Création du renderer 
________________________ */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/*
 Ajout de la Lumière 
________________________*/

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // lumière douce
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

//  Lumière ponctuelle près du modèle
const pointLight = new THREE.PointLight(0xffffff, 1, 100);
pointLight.position.set(0, 2, 2);
scene.add(pointLight);

/* Cube avec  texture 
________________________*/

const geometry = new THREE.BoxGeometry(1, 1, 1);
const texture = new THREE.TextureLoader().load('textures/ciel.jpg'); // image sur les faces du  cube
const material = new THREE.MeshBasicMaterial({ map: texture });
const cube = new THREE.Mesh(geometry, material);
cube.position.set(-5,0,0);
scene.add(cube);

/* 
   5. Charger un modèle GLTF 
_______________________________________*/
const loader = new GLTFLoader();

loader.load(
    'models/scene.gltf',
    function (gltf) {
        gltf.scene.scale.set(1.00, 1.09, 1.09); 
        gltf.scene.position.set(2, 0, 0);
        scene.add(gltf.scene);
    },
    undefined,
    function (error) {
        console.error('Erreur chargement GLTF:', error);
    }
);



/* Pluie (particules) 
________________________*/

const rainCount = 300;
const rainGeometry = new THREE.BufferGeometry();
const rainVertices = [];

for (let i = 0; i < rainCount; i++) {
    rainVertices.push(
        (Math.random() - 0.5) * 20,  // x
        Math.random() * 10,          // y
        (Math.random() - 0.5) * 20   // z
    );
}

rainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(rainVertices, 3));
const rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1 });
const rain = new THREE.Points(rainGeometry, rainMaterial);
scene.add(rain);

/* orientation du cube 
________________________*/

window.addEventListener('deviceorientation', (event) => {
    const gamma = event.gamma || 0; // gauche/droite
    const beta = event.beta || 0;   // avant/arrière
    // On fait bouger le cube en fonction de l'inclinaison
    cube.rotation.x = beta * 0.01;
    cube.rotation.y = gamma * 0.01;
});

/* Device motion : pour déplacer le modèle GLTF avec l’accéléromètre */
window.addEventListener('devicemotion', (event) => {
    if (!event.accelerationIncludingGravity) return;

    const ax = event.accelerationIncludingGravity.x || 0;
    const ay = event.accelerationIncludingGravity.y || 0;

    // On fait bouger la position du cube en fonction du mouvement du téléphone
    cube.position.x += ax * 0.01; 
    cube.position.y += ay * 0.01;

});


/* Animation 
________________________*/

function animate() {
    requestAnimationFrame(animate);

    // rotaation du cube 
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
    renderer.render(scene, camera);

    // Animation de la pluie
    const positions = rain.geometry.attributes.position.array;
    for (let i = 1; i < positions.length; i += 3) {
        positions[i] -= 0.2; // la vitesse de chute
        if (positions[i] < -5) positions[i] = 10; // réinitialisation en haut
    }
    rain.geometry.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);
}

animate();

/* Gestion du resize 
________________________*/

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script> 
</body>
</html>