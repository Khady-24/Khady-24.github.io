
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Terre 3D + Carte Leaflet</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: black;
    }

    /* Canvas BabylonJS plein écran */
    #renderCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 0;
    }

    /* Carte Leaflet en haut à gauche */
    #map {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 500px;
      height: 350px;
      border-radius: 10px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      overflow: hidden;
      background-color: rgba(255,255,255,0.85);
    }

    .leaflet-control-attribution {
      font-size: 10px;
    }
  </style>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
</head>
<body>
  <!-- Carte Leaflet -->
  <div id="map"></div>

  <!-- Canvas BabylonJS -->
  <canvas id="renderCanvas"></canvas>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- BabylonJS -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

  <script>

// rotation horizontale à appliquer aux longitudes (en degrés).
// Ajuste si nécessaire : -90 ou +90 corrige souvent l'alignement.
const LON_OFFSET_DEG = -90;







    /********************
     * Variables globales
     ********************/
    let camera;                // pour utiliser camera en dehors de createScene
    let latLonToVector3;       // pour utiliser la fonction partout

    /********************
     *  PARTIE LEAFLET
     ********************/
    const map = L.map("map").setView([20, 0], 2);

    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap contributors"
    }).addTo(map);

    const stamen = L.tileLayer("https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png", {
      attribution: "© Stamen Design"
    });

    L.control.layers({ "OSM": osm, "Stamen": stamen }).addTo(map);

    /********************
     *  PARTIE BABYLON
     ********************/
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = () => {
      const scene = new BABYLON.Scene(engine);

      // Caméra
      camera = new BABYLON.ArcRotateCamera(
        "camera",
       0,
      0,
        6,
        BABYLON.Vector3.Zero(),
        scene
      );
      camera.attachControl(canvas, true);
      camera.panningSensibility = 0;
      camera.allowUpsideDown = true;
      camera.lowerRadiusLimit = 2;
      camera.upperRadiusLimit = 10;

      // Lumière
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 1.1;


    
      // Sphère Terre
      sphere = BABYLON.MeshBuilder.CreateSphere("earth", { diameter: 2, segments: 64 }, scene);
      //sphere.scaling = new BABYLON.Vector3(-1,1,1);
      const material = new BABYLON.StandardMaterial("earthMat", scene);
      material.diffuseTexture = new BABYLON.Texture("CarteDuMonde2.png", scene);
      material.diffuseTexture.uScale = -1;
      material.diffuseTexture.vScale = -1; // on inverse verticalement


      material.specularColor = new BABYLON.Color3(0,0,0);
      material.emissiveColor = new BABYLON.Color3(0.2,0.2,0.2);

      //material.diffuseColor.vScale=-1;
    
      sphere.material = material;
      //sphere.rotation.y = Math.PI / 2;
sphere.rotation.y = -Math.PI / 85; // ≈ -18°



      /* 
      material
     material.vscale = 1;
      material.uscale = -1;
      material.rotation.x = Math.PI; */

      
      // Fonction Lat/Lon -> Vector3
      latLonToVector3 = function(lat, lon, radius=1) {
       // const phi = (90 - lat) * (Math.PI / 180);
       // const theta = (lon + 180) * (Math.PI / 180);
        const phi = (90 - lat) * Math.PI / 180;    // latitude -> angle polaire
        const theta = (lon - 180) * Math.PI / 180; // longitude -> angle azimutal
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        return new BABYLON.Vector3(x, y, z);
      };

// --- Point test à 0°N, 0°E ---
const zeroPoint = BABYLON.MeshBuilder.CreateSphere("zeroPoint", { diameter: 0.05 }, scene);
zeroPoint.position = latLonToVector3(0, 0, 1.05); // un peu au-dessus de la sphère
const zeroMat = new BABYLON.StandardMaterial("zeroMat", scene);
zeroMat.diffuseColor = new BABYLON.Color3(1, 0, 1); // magenta pour bien voir
zeroMat.specularColor = new BABYLON.Color3(0, 0, 0);
zeroPoint.material = zeroMat;


      // Marqueurs pays
      /*const countries = [
        { name: "Senegal", lat: 14.4974, lon: -14.4524, color: 0xff0000 },
        { name: "Arabie Saoudite", lat: 23.8859, lon: 45.0792, color: 0x008000 },
        { name: "Maroc", lat: 31.7917, lon: -7.0926, color: 0xffd700 },
        { name: "Algerie", lat: 28.0339, lon: 1.6596, color: 0x0000ff },
        { name: "France", lat: 46.2276, lon: 2.2137, color: 0x0000ff },
        { name: "Espagne", lat: 40.4637, lon: -3.7492, color: 0xff0000 },
        { name: "Italie", lat: 41.8719, lon: 12.5674, color: 0x008000 },
        { name: "Allemagne", lat: 51.1657, lon: 10.4515, color: 0x0000ff },
        { name: "Royaume Uni", lat: 55.3781, lon: -3.4360, color: 0xff0000 }
      ];

      countries.forEach(c => {
        const marker = BABYLON.MeshBuilder.CreateSphere(c.name, { diameter: 0.05 }, scene);
        marker.position = latLonToVector3(c.lat, c.lon, 1.01);
        const mat = new BABYLON.StandardMaterial(c.name + "Mat", scene);
        mat.diffuseColor = BABYLON.Color3.FromHexString("#" + c.color.toString(16).padStart(6,'0'));
        marker.material = mat;

        // ActionManager pour cliquer sur le marqueur
        marker.actionManager = new BABYLON.ActionManager(scene);
        marker.actionManager.registerAction(
          new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
            map.setView([c.lat, c.lon], 5);
          })
        );
      });

      */


      // --- Récupération des pays et création des drapeaux ---2
      /*
fetch("https://restcountries.com/v3.1/all")
  .then(res => res.json())
  .then(data => {
    data.forEach(country => {
      if (!country.latlng || country.latlng.length !== 2 || !country.flags) return;

      const lat = country.latlng[0];
      const lon = country.latlng[1];
      const flagUrl = country.flags.png;

      // Définir un rayon légèrement supérieur à celui de la sphère
      const baseRadius = 1;      // rayon de la Terre
      const offset = 0.08;       // distance devant la sphère
      const radius = baseRadius + offset;

      // Création du plane pour le drapeau
      const plane = BABYLON.MeshBuilder.CreatePlane(
        country.name.common + "Flag",
        { width: 0.2, height: 0.1 },
        scene
      );
      plane.position = latLonToVector3(lat, lon, radius);

      // Material avec gestion CORS
      const matFlag = new BABYLON.StandardMaterial(country.name.common + "FlagMat", scene);
      matFlag.diffuseTexture = new BABYLON.Texture(flagUrl, scene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, null, null, true);
      matFlag.specularColor = new BABYLON.Color3(0, 0, 0);
      plane.material = matFlag;

      // Toujours orienté vers la caméra
      plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

      // Interaction clic : recentre la carte Leaflet
      plane.actionManager = new BABYLON.ActionManager(scene);
      plane.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
          map.setView([lat, lon], 5);
        })
      );
    });
  });
*/



// test avec un drapeau ...
const plane = BABYLON.MeshBuilder.CreatePlane("FranceFlag", {width:0.15, height:0.15}, scene);
plane.position = latLonToVector3(46.2276, 2.2137, 1.01);
const mat = new BABYLON.StandardMaterial("FranceFlagMat", scene);
mat.diffuseTexture = new BABYLON.Texture("https://flagcdn.com/w320/fr.png", scene);
mat.specularColor = new BABYLON.Color3(0,0,0);
plane.material = mat;
plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
plane.actionManager = new BABYLON.ActionManager(scene);
plane.actionManager.registerAction(
  new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
    map.setView([46.2276, 2.2137], 5);
  })
);

      // Marqueur de position utilisateur
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const myMarker = BABYLON.MeshBuilder.CreateSphere("myPos", { diameter: 0.05 }, scene);
          myMarker.position = latLonToVector3(lat, lon, 1.01);
          const mat = new BABYLON.StandardMaterial("myPosMat", scene);
          mat.diffuseColor = new BABYLON.Color3(1,0,0);
          myMarker.material = mat;

          // ActionManager pour cliquer sur le marqueur
          myMarker.actionManager = new BABYLON.ActionManager(scene);
          myMarker.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
              map.setView([lat, lon], 5);
            })
          );
        });
      }

      return scene;
    };

    const scene = createScene();

    //  interaction Leaflet carte et sphere 
    map.on('click', function(e) {
      const lat = e.latlng.lat;
      const lon = e.latlng.lng;

    const targetPos = latLonToVector3(lat, lon, 1);

      const radius = camera.radius;
      const phi = Math.acos(targetPos.y / radius);
      const theta = Math.atan2(targetPos.z, targetPos.x);

      camera.alpha = theta + Math.PI/2;
      camera.beta = phi;

    });

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
