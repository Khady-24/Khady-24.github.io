
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Terre 3D + Carte Leaflet</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: black;
    }

    /* Canvas BabylonJS plein écran */
    #renderCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 0;
    }

    /* Carte Leaflet en haut à gauche */
    #map {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 500px;
      height: 350px;
      border-radius: 10px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      overflow: hidden;
      background-color: rgba(255,255,255,0.85);
    }

    .leaflet-control-attribution {
      font-size: 10px;
    }
  </style>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
</head>
<body>
  <!-- Carte Leaflet -->
  <div id="map"></div>

  <!-- Canvas BabylonJS -->
  <canvas id="renderCanvas"></canvas>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- BabylonJS -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

  <script>

// rotation horizontale appliqué aux longitudes .
const LON_OFFSET_DEG = -90; 



    /********************
     * Variables globales
     ********************/
    let camera;                // pour utiliser camera en dehors de createScene
    let latLonToVector3;       // pour utiliser la fonction partout

    /********************
     *  PARTIE LEAFLET
     ********************/
    const map = L.map("map").setView([20, 0], 2);

    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap contributors"
    }).addTo(map);

    const stamen = L.tileLayer("https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png", {
      attribution: "© Stamen Design"
    });

    L.control.layers({ "OSM": osm, "Stamen": stamen }).addTo(map);

    /********************
     *  PARTIE BABYLON
     ********************/
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = () => {
      const scene = new BABYLON.Scene(engine);

      // Caméra
      camera = new BABYLON.ArcRotateCamera(
        "camera",
       0,
      0,
        6,
        BABYLON.Vector3.Zero(),
        scene
      );
      camera.attachControl(canvas, true);
      camera.panningSensibility = 0;
      camera.allowUpsideDown = true;
      camera.lowerRadiusLimit = 2;
      camera.upperRadiusLimit = 10;

      // Lumière
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 1.1;

    
      // Sphère Terre
      sphere = BABYLON.MeshBuilder.CreateSphere("earth", { diameter: 2, segments: 64 }, scene);
      const material = new BABYLON.StandardMaterial("earthMat", scene);
      material.diffuseTexture = new BABYLON.Texture("CarteDuMonde2.png", scene);
      material.diffuseTexture.uScale = -1;
      material.diffuseTexture.vScale = -1; // on inverse verticalement

      material.specularColor = new BABYLON.Color3(0,0,0);
      material.emissiveColor = new BABYLON.Color3(0.2,0.2,0.2);
    
      sphere.material = material;
      sphere.rotation.y = -Math.PI / 80; 

      // Fonction Lat/Lon -> Vector3
      latLonToVector3 = function(lat, lon, radius=1) {
    
        const phi = (90 - lat) * Math.PI / 180;    // latitude -> angle polaire
        const theta = (lon - 180) * Math.PI / 180; // longitude -> angle azimutal

        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        return new BABYLON.Vector3(x, y, z);
      };

// --- Point test à 0°N, 0°E ---
const zeroPoint = BABYLON.MeshBuilder.CreateSphere("zeroPoint", { diameter: 0.05 }, scene);
zeroPoint.position = latLonToVector3(0, 0, 1.05); // un peu au-dessus de la sphère
const zeroMat = new BABYLON.StandardMaterial("zeroMat", scene);
zeroMat.diffuseColor = new BABYLON.Color3(1, 0, 1); // magenta pour bien voir
zeroMat.specularColor = new BABYLON.Color3(0, 0, 0);
zeroPoint.material = zeroMat;


//  Affichage des drapeaux des Pays sur la sphere 
    
fetch("https://restcountries.com/v3.1/all?fields=name,latlng,flags")
  .then(res => res.json())
  .then(data => {
    data.forEach(country => {
      if (!country.latlng || country.latlng.length !== 2 || !country.flags) return;

      const lat = country.latlng[0];
      const lon = country.latlng[1];
      const flagUrl = country.flags.png;

      const radius = 1.05; // légèrement au-dessus de la sphère
      const plane = BABYLON.MeshBuilder.CreatePlane(country.name.common + "Flag", { width: 0.08, height: 0.05 }, scene);
      plane.position = latLonToVector3(lat, lon, radius);

      const matFlag = new BABYLON.StandardMaterial(country.name.common + "FlagMat", scene);
      matFlag.diffuseTexture = new BABYLON.Texture(flagUrl, scene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, null, null, true);
      matFlag.specularColor = new BABYLON.Color3(0,0,0);
      plane.material = matFlag;

      plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

      // Interaction clic
      plane.actionManager = new BABYLON.ActionManager(scene);
      plane.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
          map.setView([lat, lon], 5);
          const phi = (90 - lat) * Math.PI / 180;
          const theta = (lon + 180 + LON_OFFSET_DEG) * Math.PI / 180;
          camera.alpha = theta + Math.PI/2;
          camera.beta = phi;
        })
      );
    });
  });



  // ---Affichage des drapeaux des Pays la carte du monde Leaflet ---
fetch("https://restcountries.com/v3.1/all?fields=name,latlng,flags")
  .then(res => res.json())
  .then(data => {
    data.forEach(country => {
      if (!country.latlng || country.latlng.length !== 2 || !country.flags) return;

      const lat = country.latlng[0];
      const lon = country.latlng[1];
      const flagUrl = country.flags.png;

      const flagIcon = L.icon({
        iconUrl: flagUrl,
        iconSize: [13, 9], // iconSize[largeur, hauteur]
        iconAnchor: [12, 7],
      });

      const marker = L.marker([lat, lon], { icon: flagIcon }).addTo(map);

      marker.on("click", () => {
        const phi = (90 - lat) * Math.PI / 180;
        const theta = (lon + 180 + LON_OFFSET_DEG) * Math.PI / 180;
        camera.alpha = theta + Math.PI/2;
        camera.beta = phi;

        map.setView([lat, lon], 5);
      });
    });
  });

      // Marqueur de position ( point sur la france )
    
    if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        const radius = 1.05; // légèrement au-dessus de la sphère

        // --- POINT BLEU ---
        const point = BABYLON.MeshBuilder.CreateSphere("myPos", { diameter: 0.05 }, scene);
        point.position = latLonToVector3(lat, lon, radius);

        const mat = new BABYLON.StandardMaterial("myPosMat", scene);
        mat.diffuseColor = new BABYLON.Color3(0, 0, 1); // bleu
        mat.specularColor = new BABYLON.Color3(0,0,0);
        point.material = mat;

        // --- TEXTE AU-DESSUS "Vous êtes ici "---
        const label = BABYLON.MeshBuilder.CreatePlane("userText", { width: 0.4, height: 0.1 }, scene);
        label.position = latLonToVector3(lat, lon, radius + 0.08);
        label.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

        const labelMat = new BABYLON.StandardMaterial("labelMat", scene);
        const dynamicTexture = new BABYLON.DynamicTexture("dynText", { width:512, height:128 }, scene, true);
        dynamicTexture.hasAlpha = true;
        dynamicTexture.drawText("Vous êtes ici", null, 80, "bold 60px Arial", "blue", "transparent", true);
        labelMat.diffuseTexture = dynamicTexture;
        labelMat.specularColor = new BABYLON.Color3(0,0,0);
        label.material = labelMat;

        // --- Interaction au clic   ---
        point.actionManager = new BABYLON.ActionManager(scene);
        point.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
                map.setView([lat, lon], 5);
                const phi = (90 - lat) * Math.PI / 180;
                const theta = (lon + 180 + LON_OFFSET_DEG) * Math.PI / 180;
                camera.alpha = theta + Math.PI/2;
                camera.beta = phi;
            })
        );
    });
}

      return scene;
    };

    const scene = createScene();

    //  interaction Leaflet carte et sphere 
  
map.on('click', function(e) {
    const lat = e.latlng.lat;
    const lon = e.latlng.lng;

    const phi = (90 - lat) * Math.PI / 180;
    const theta = (lon + 180 + LON_OFFSET_DEG) * Math.PI / 180;

    camera.alpha = theta + Math.PI/2;  // ajuste si la rotation semble inversée
    camera.beta = phi;
});

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
